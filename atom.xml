<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bb7bb&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-24T13:01:28.368Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>bb7bb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Vue实现拖拽效果</title>
    <link href="http://yoursite.com/2018/04/24/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2018/04/24/基于Vue实现拖拽效果/</id>
    <published>2018-04-24T13:00:00.000Z</published>
    <updated>2018-04-24T13:01:28.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10414430-93d8911b63914b85.gif?imageMogr2/auto-orient/strip" alt="demo1.gif"></p><h2 id="分清clientY-pageY-screenY-layerY-offsetY的区别"><a href="#分清clientY-pageY-screenY-layerY-offsetY的区别" class="headerlink" title="分清clientY pageY screenY layerY offsetY的区别"></a>分清clientY pageY screenY layerY offsetY的区别</h2><p>在我们想要做出拖拽这个效果的时候，我们需要分清这几个属性的区别，这几个属性都是计算鼠标点击的偏移值，我们需要对其进行了解才可以继续实现我们的拖拽效果</p><ul><li>clientY 指的是距离可视页面左上角的距离</li><li>pageY 指的是距离可视页面左上角的距离(不受页面滚动影响)</li><li>screenY 指的是距离屏幕左上角的距离</li><li>layerY 指的是找到它或它父级元素中最近具有定位的左上角距离</li><li>offsetY 指的是距离它自己左上角的距离</li></ul><p>一张图带大家简单了解了解</p><p><img src="https://upload-images.jianshu.io/upload_images/10414430-a468320f760ce39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区别"></p><p>在我们简单了解完这些个属性以后，有几个属性需要分清。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">相同点</th><th style="text-align:center">不同点</th></tr></thead><tbody><tr><td style="text-align:center">clientY</td><td style="text-align:center">距离页面左上角距离</td><td style="text-align:center">受页面滚动的影响</td></tr><tr><td style="text-align:center">pageY</td><td style="text-align:center">距离页面左上角的距离</td><td style="text-align:center">不受页面滚动影响</td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td style="text-align:center">layerY</td><td>距离元素的左上角距离</td><td>受元素的定位的影响，会从本元素往上找到第一个定位的元素的左上角</td></tr><tr><td style="text-align:center">offsetY</td><td>距离元素左上角的距离</td><td>计算相对于本元素的左上角，不在乎定位问题，计算的是内交点。是IE浏览器的特有属性</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/10414430-6c1bccb989903dfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layerY与offsetY区别"></p><h2 id="实现拖拽功能"><a href="#实现拖拽功能" class="headerlink" title="实现拖拽功能"></a>实现拖拽功能</h2><p>我们既然熟悉了这几个偏移属性的意思，那么我们就进入我们的重点。话不多说直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// darg.html</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #app&#123;</span><br><span class="line">    position: relative;     /*定位*/</span><br><span class="line">    top: 10px;</span><br><span class="line">    left: 10px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: #666;       /*设置一下背景*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot; @mousedown=&quot;move&quot;&gt;       &lt;!--绑定按下事件--&gt;</span><br><span class="line">    &#123;&#123;positionX&#125;&#125;</span><br><span class="line">        &#123;&#123;positionY&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        positionX:0,</span><br><span class="line">        positionY:0,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        move(e)&#123;</span><br><span class="line">            let odiv = e.target;        //获取目标元素</span><br><span class="line">            </span><br><span class="line">            //算出鼠标相对元素的位置</span><br><span class="line">            let disX = e.clientX - odiv.offsetLeft;</span><br><span class="line">            let disY = e.clientY - odiv.offsetTop;</span><br><span class="line">            document.onmousemove = (e)=&gt;&#123;       //鼠标按下并移动的事件![image](https://note.youdao.com/favicon.ico)</span><br><span class="line">                //用鼠标的位置减去鼠标相对元素的位置，得到元素的位置</span><br><span class="line">                let left = e.clientX - disX;    </span><br><span class="line">                let top = e.clientY - disY;</span><br><span class="line">                </span><br><span class="line">                //绑定元素位置到positionX和positionY上面</span><br><span class="line">                this.positionX = top;</span><br><span class="line">                this.positionY = left;</span><br><span class="line">                </span><br><span class="line">                //移动当前元素</span><br><span class="line">                odiv.style.left = left + &apos;px&apos;;</span><br><span class="line">                odiv.style.top = top + &apos;px&apos;;</span><br><span class="line">            &#125;;</span><br><span class="line">            document.onmouseup = (e) =&gt; &#123;</span><br><span class="line">                document.onmousemove = null;</span><br><span class="line">                document.onmouseup = null;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，我们可以将它绑定为一个自定义指令，这样的话就可以用调用指令的形式来实现拖拽效果，下面是定义自定义指令的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// darg.html</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #app&#123;</span><br><span class="line">    position: relative;     /*定位*/</span><br><span class="line">    top: 10px;</span><br><span class="line">    left: 10px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: #666;       /*设置一下背景*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot; v-drag&gt;       &lt;!--实现用指令形式实现拖拽效果--&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    methods:&#123;&#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        drag: &#123;</span><br><span class="line">            // 指令的定义</span><br><span class="line">            bind: function (el) &#123;</span><br><span class="line">                let odiv = el;   //获取当前元素</span><br><span class="line">                oDiv.onmousedown = (e) =&gt; &#123;</span><br><span class="line">                    //算出鼠标相对元素的位置</span><br><span class="line">                    let disX = e.clientX - odiv.offsetLeft;</span><br><span class="line">                    let disY = e.clientY - odiv.offsetTop;</span><br><span class="line">                    </span><br><span class="line">                    document.onmousemove = (e)=&gt;&#123;</span><br><span class="line">                        //用鼠标的位置减去鼠标相对元素的位置，得到元素的位置</span><br><span class="line">                        let left = e.clientX - disX;    </span><br><span class="line">                        let top = e.clientY - disY;</span><br><span class="line">                      </span><br><span class="line">                        //绑定元素位置到positionX和positionY上面</span><br><span class="line">                        this.positionX = top;</span><br><span class="line">                        this.positionY = left;</span><br><span class="line">                </span><br><span class="line">                        //移动当前元素</span><br><span class="line">                        odiv.style.left = left + &apos;px&apos;;</span><br><span class="line">                        odiv.style.top = top + &apos;px&apos;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    document.onmouseup = (e) =&gt; &#123;</span><br><span class="line">                        document.onmousemove = null;</span><br><span class="line">                        document.onmouseup = null;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>到这里我们就已经把拖拽效果用Vue实现了，我们用了两种不同的方式实现了拖拽，但实际上换汤不换药，我们需要弄清楚pageY、screenY、clientY、layerY、offsetY等区别。当然我们同时也学习了Vue的一些方法，例如自定义指令等。</p><p>成功不在一朝一夕间，我们都需要努力</p><p>原创文章，转载需联系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10414430-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简述JavaScript闭包</title>
    <link href="http://yoursite.com/2018/04/22/%E7%AE%80%E8%BF%B0JavaScript%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/04/22/简述JavaScript闭包/</id>
    <published>2018-04-22T08:22:48.000Z</published>
    <updated>2018-04-22T08:28:36.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引入闭包"><a href="#1-引入闭包" class="headerlink" title="1.引入闭包"></a>1.引入闭包</h2><ul><li>我们先从两个经典例子中提出我们的问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function a(b)&#123;</span><br><span class="line">    var c = &quot;123&quot;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = a(&quot;b&quot;);</span><br><span class="line">b();    //&quot;b&quot; &quot;123&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let func = function()&#123;</span><br><span class="line">    var arr = new Array();</span><br><span class="line">    for(var i = 0 ; i &lt; 5;i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当然，如果你有了解过相关闭包的知识，那么上面的每个数组函数都会返回<code>5</code>。在这里可以很明确的告诉你这就是闭包。闭包究竟是什么，按照红宝书上面的定义是这么解释的</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数</p></blockquote><p>当然，我觉得闭包有一点也特别重要，创建闭包时就创建了一个<strong>不销毁的作用域</strong>。<br>接下来我就简单的剖析一下闭包，说到闭包总不能忘记几个概念，<strong>作用域链</strong>、<strong>执行上下文</strong>、<strong>变量对象</strong></p><h2 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2.执行上下文"></a>2.执行上下文</h2><p>当我们调用一个函数的时候就会创建一个函数的环境，我们可以称之为<strong>执行环境</strong>，简单点也可称之为环境。当然，咱们在这里叫作<strong>执行上下文</strong>。当然，<strong>每个函数都会有各自的执行上下文</strong>。简单来说，就是函数里面的执行环境。++执行上下文定义了变量或函数有权访问其他数据++，++决定了他们各自的行为++。</p><h2 id="3-变量对象"><a href="#3-变量对象" class="headerlink" title="3.变量对象"></a>3.变量对象</h2><p>每个执行上下文中有会有与之关联的<strong>变量对象</strong>，在上下文中定义的所有变量和函数都会放在这里面。当然我们是取不到它的，我们只能想象它的存在。解析器在处理数据的时候就会在后台使用变量对象。但是如果在函数中的话，我们称之为<strong>活动对象</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">var b = 0;</span><br><span class="line">function abc(c)&#123;</span><br><span class="line">    var b = 1;</span><br><span class="line">    return a+b+c;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abc(3)  //5</span><br></pre></td></tr></table></figure><p>那么上面这个例子是不是闭包？当然不是，第一它没有创建一个不销毁的作用域，第二他没有返回引用类型。但是上面这个函数可以帮我们理解变量对象。那么上例中函数<code>abc</code>的活动对象是<code>b、c</code>，全局的变量对象是<code>a、b</code></p><h2 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h2><p><strong>作用域链</strong>是用来指向变量对象的，<strong>作用域的用途是保证对执行环境有权访问的所有变量和函数的有序访问</strong>。作用域的前面，始终都是<strong>当前执行</strong>的代码所在环境的变量对象</p><p>我们回到上面那个<code>abc</code>的例子，在创建abc函数的时候就会创建一个包含全局变量对象的作用域链，当调用<code>abc</code>函数时，就会将<code>abc</code>的活动对象推到作用域链的前端，当函数要寻找变量时就会按照作用域链依次往下找</p><p><img src="http://on-img.com/chart_image/5ac47dede4b00dc8a02ceecc.png" alt="image"></p><p>所以上例子中，<code>abc</code>函数会先在活动对象变量<code>b，c</code>，再到外部去寻找<code>a</code>，因此结果得到为<code>6</code>。</p><h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5.闭包"></a>5.闭包</h2><p>既然作用域链、变量对象、执行上下文我们都简述了一遍，那么接下来我们说回闭包。</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数</p></blockquote><p>我们再一次把闭包的定义扔出来，这下子我们就大概清晰许多了。那么我们接下来创建闭包函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function abc(c)&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let test = abc(2);</span><br><span class="line">let result = test(3);       //6</span><br></pre></td></tr></table></figure></p><p>当我们调用<code>abc</code>函数时，其<code>abc</code>活动对象就会推到作用域链的前端，当我们返回其匿名函数时，匿名函数的活动对象就会被推到作用域链的前端，因此在里面就可以访问到外面的值。</p><p><img src="http://on-img.com/chart_image/5ac58033e4b0cfe27482a194.png" alt="image"></p><p>由于我们将<code>test</code>变量赋予了<code>abc</code>的返回值，函数<code>abc</code>中就产生一个<strong>无法销毁的活动对象</strong>，匿名函数的作用域链一直引用其<code>abc</code>函数活动对象。因此在内存就产生了一个不销毁的活动对象，这也是导致内存泄漏的原因。这么来说，只要<code>test</code>一直存在，那么abc的活动对象都不会被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function abc(c)&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let test = abc(2);</span><br><span class="line">let result = test(3);       //6</span><br><span class="line"></span><br><span class="line">test=null;  //解除对匿名函数引用，释放abc活动对象，随后执行完便可被回收</span><br></pre></td></tr></table></figure></p><p>那么问题又来了，以下的函数算不算闭包呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function abc(c)&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abc(2)(3);      //6</span><br></pre></td></tr></table></figure></p><p>看上去和上面没什么区别，实际上这已经不是闭包了。原因在于它没有创建一个不销毁的作用域链，它并没有定义一个变量去引用这个匿名函数，所以该函数在执行完以后就会被销毁。这只是一个普通的匿名函数而已。</p><p>说完我们回到第一个问题上面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let func = function()&#123;</span><br><span class="line">    var arr = new Array();</span><br><span class="line">    for(var i = 0 ; i &lt; 5;i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个每个数组函数中返回的都是<code>5</code>，原因在于<strong>闭包保存的是整个变量对象</strong>，因此每个函数中都<strong>保存一样的变量对象</strong>。它们引用的都是一个变量<code>i</code>。所以在执行闭包时，<code>i</code>已经执行到<code>5</code>,返回的<code>i</code>自然便是<code>5</code>。</p><ul><li><strong>闭包的作用</strong></li></ul><p>闭包的作用就是可以在内存中保留一些变量，使其不被销毁。当然，还有重要的一点就是可以访问外界的变量与函数，取到另外一个作用域上面的值。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们对闭包的简述就到这里了，想要深入了解闭包还需要花更多功夫在上面。成功不是在一朝一夕之间，我们都需要努力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-引入闭包&quot;&gt;&lt;a href=&quot;#1-引入闭包&quot; class=&quot;headerlink&quot; title=&quot;1.引入闭包&quot;&gt;&lt;/a&gt;1.引入闭包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们先从两个经典例子中提出我们的问题&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/22/hello-world/"/>
    <id>http://yoursite.com/2018/04/22/hello-world/</id>
    <published>2018-04-22T01:51:12.139Z</published>
    <updated>2018-04-22T01:51:12.139Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
