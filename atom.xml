<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bb7bb&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-29T08:17:51.553Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>bb7bb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript中this指向的深入解析</title>
    <link href="http://yoursite.com/2018/07/29/Javascript%E4%B8%ADthis%E6%8C%87%E5%90%91%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/29/Javascript中this指向的深入解析/</id>
    <published>2018-07-29T08:00:00.000Z</published>
    <updated>2018-07-29T08:17:51.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通函数的this指向"><a href="#普通函数的this指向" class="headerlink" title="普通函数的this指向"></a>普通函数的this指向</h2><h3 id="简单说说"><a href="#简单说说" class="headerlink" title="简单说说"></a>简单说说</h3><p>首先，按照惯例，我们先举个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var bar = 2;</span><br><span class="line">function foo() &#123;</span><br><span class="line">  this.bar = 1;</span><br><span class="line">  this.getBar = function() &#123;</span><br><span class="line">    console.log(this.bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var test = new foo();</span><br><span class="line">var getBar = test.getBar;</span><br><span class="line"></span><br><span class="line">test.getBar();  //1</span><br><span class="line">getBar();       //2</span><br></pre></td></tr></table></figure></p><p>通过这个例子我们就能看到，虽然是同一个函数，但是实际上得到的结果却不一样。这个原因相信大家都能知道。不知道的也告诉你：<strong>this其实是指向调用该函数的那个对象</strong>。那么当我们在全局环境中调用的时候，this自然就指向了全局环境。</p><p>那么到是有个问题：this为什么会随调用者变化而变化？</p><p>这可能需要你继续往下看看</p><h3 id="深入说说"><a href="#深入说说" class="headerlink" title="深入说说"></a>深入说说</h3><p>那么如果说深层次的理解this的指向，我觉得大概可以从数据类型讲起</p><p>我们都知道，栈中存放的是基本数据类型，也就是<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Symbol</code>、<code>Null</code>、<code>Undefined</code>这七种数据类型，当然<code>Symbol</code>是ES6新增的一个数据类型。那么堆中存放的就是一些引用类型了，如<code>Obejct</code>、<code>Function</code>。实际上当我们<strong>定义一个引用类型的时候，js会同时定义一个地址指针指向内存中的对象</strong>。</p><p>例如：当我们声明一个字面量对象时候<code>let a = {num:1};</code>实际上<code>a</code>中存放的是指向<code>{num:1}</code>的地址</p><p><img src="https://upload-images.jianshu.io/upload_images/10414430-0790a9b8f1c3df2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="定义引用类型时"></p><p>现在我们解析一下上面那段代码是如何执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 在全局环境下定义一个变量bar</span><br><span class="line">var bar = 2;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    //在foo中也声明了一个bar</span><br><span class="line">    this.bar = 1;</span><br><span class="line">    </span><br><span class="line">    //在foo中声明一个getBar函数</span><br><span class="line">    this.getBar = function() &#123;</span><br><span class="line">        console.log(this.bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构造函数模式自定义对象，将foo的this赋予test</span><br><span class="line">var test = new foo();</span><br><span class="line"></span><br><span class="line">//将test中的getBar方法赋予getBar</span><br><span class="line">var getBar = test.getBar;</span><br><span class="line"></span><br><span class="line">//调用test中的getBar</span><br><span class="line">test.getBar();  //1</span><br><span class="line"></span><br><span class="line">//调用getBar</span><br><span class="line">getBar();       //2</span><br></pre></td></tr></table></figure></p><p>现在列出来一看，放佛恍然大悟，终于知道为啥输出的是不同的结果了。那么我这里倒是有几个问题</p><ul><li><strong>为什么调用同一个函数却有不同的结果？</strong></li><li><strong>foo中的this是指向foo的，为什么foo中的函数可以取得外部的this？</strong></li><li><strong>为什么this会随调用它的对象变化而变化？</strong></li></ul><p>ok，其实要弄清楚上述问题，我们需要明白一点，函数也是个引用类型。那么我们上面讲过，创建引用类型的时候会同时创建一个地址指针。那么我们就可以这样理解上面的foo对象</p><p><img src="https://upload-images.jianshu.io/upload_images/10414430-d3c7dfe66fc35b5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="this.png"></p><p>*实际上foo中的getBar只是存放了一个函数的地址而已**。那么这个函数并不是foo所私有。什么东西是foo的呢？一个值为1的bar和一个指向<code>function() {console.log(this.bar);}</code>函数的getBar而已。</p><p>这样我们就不难理解，为什么调用同一个函数会有不一样的结果了，<strong>因为这个函数并不是<code>foo</code>所私有</strong>。好比内存就是深圳，函数就只是深圳的一套房。<code>getBar</code>就是这套房的钥匙。那么一开始<code>foo</code>这个人建好了这房子，就他有这房子的钥匙，那么当然只有他能进出该房子，后来有一天他把钥匙多配了一把给了<code>window</code>这好朋友。于是乎<code>window</code>也能进这套房了。给<code>window</code>配钥匙的过程：<code>var getBar = test.getBar;</code>这里只是<strong>将该函数的地址赋给全局下的getBar</strong>而已，房子也只是一套房子，函数还是一个函数。</p><blockquote><p>由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p></blockquote><p>所以当window调用这个函数的时候，this就不是指向foo了。而是指向window。this是指向他们自己。window的衣服不会在进了foo的房子以后就变成foo的衣服。</p><p>ok，我们现在再把刚刚的代码重新注释一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 在全局环境下定义一个变量bar</span><br><span class="line">var bar = 2;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    //在foo中也声明了一个bar</span><br><span class="line">    this.bar = 1;</span><br><span class="line">    </span><br><span class="line">    //在foo中声明一个getBar函数，getBar存放该函数的地址</span><br><span class="line">    this.getBar = function() &#123;</span><br><span class="line">        console.log(this.bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构造函数模式自定义对象，将foo的this赋予test</span><br><span class="line">var test = new foo();</span><br><span class="line"></span><br><span class="line">//将test中的getBar方法的地址赋予全局的getBar</span><br><span class="line">var getBar = test.getBar;</span><br><span class="line"></span><br><span class="line">//调用test中的getBar函数</span><br><span class="line">test.getBar();  //1</span><br><span class="line"></span><br><span class="line">//调用getBar函数</span><br><span class="line">getBar();       //2</span><br></pre></td></tr></table></figure></p><p>于是乎我们就把普通的this指向弄明白了。顺便还明白了堆栈的区别。接下来看看不普通的函数this指向是如何的</p><h2 id="箭头函数this指向"><a href="#箭头函数this指向" class="headerlink" title="箭头函数this指向"></a>箭头函数this指向</h2><p><strong>箭头函数内没有this，箭头函数的this是父级函数的this</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 在全局环境下定义一个变量bar</span><br><span class="line">var bar = 2;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    //在foo中也声明了一个bar</span><br><span class="line">    this.bar = 1;</span><br><span class="line">    </span><br><span class="line">    //在foo中定义一个箭头函数，getBar存放该函数的地址</span><br><span class="line">    this.getBar = () =&gt; &#123;</span><br><span class="line">        console.log(this.bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构造函数模式自定义对象，将foo的this赋予test</span><br><span class="line">var test = new foo();</span><br><span class="line"></span><br><span class="line">//将test中的getBar方法的地址赋予全局的getBar</span><br><span class="line">var getBar = test.getBar;</span><br><span class="line"></span><br><span class="line">//调用test中的getBar函数</span><br><span class="line">test.getBar();  //1</span><br><span class="line"></span><br><span class="line">//调用getBar函数</span><br><span class="line">getBar();       //1</span><br></pre></td></tr></table></figure><p>如果定义了箭头函数的情况下，this执行就不会随意的改变了。普通函数的this是会跟随调用者变化，但是箭头函数就很特别，<strong>他只会继承父级的this</strong>，<strong>而且一旦建立就不会改变了</strong>。所以在这里我们就可以看见，尽管全局下面调用getBar，但是实际上还是取到了foo的this。</p><p>因此箭头函数不可以用来当作构造函数。因为它本身是没有this的！</p><p>所以箭头函数使用的话需要与普通函数区别开这点，它的this指向定义函数时候的父级。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>关于this就介绍到这里，如果有什么不懂的欢迎随时提问，我会随时回答大家的问题。</p><p>那么最后，成功不在一朝一夕，我们都需要努力</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;普通函数的this指向&quot;&gt;&lt;a href=&quot;#普通函数的this指向&quot; class=&quot;headerlink&quot; title=&quot;普通函数的this指向&quot;&gt;&lt;/a&gt;普通函数的this指向&lt;/h2&gt;&lt;h3 id=&quot;简单说说&quot;&gt;&lt;a href=&quot;#简单说说&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>快速入门react</title>
    <link href="http://yoursite.com/2018/07/22/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8react/"/>
    <id>http://yoursite.com/2018/07/22/快速入门react/</id>
    <published>2018-07-22T13:00:00.000Z</published>
    <updated>2018-07-29T08:19:48.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装react"><a href="#安装react" class="headerlink" title="安装react"></a>安装react</h2><p><code>npm install creat-react-app -g</code></p><p>这里直接安装react的一个脚手架，里面包含了要用到的许多东西，帮助快速入门react</p><h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><ol><li><code>create-react-app my-app</code></li><li><code>cd my-app</code></li><li><code>npm start</code></li></ol><p>用脚手架创建一个新的单页应用，进到项目里面后<code>start</code>跑起来</p><h2 id="react组件"><a href="#react组件" class="headerlink" title="react组件"></a>react组件</h2><ul><li>引入Component组件</li><li>JSX语法</li><li>渲染虚拟DOM</li><li>组件props</li><li>组件state</li><li>组件嵌套</li><li>组件生命周期</li></ul><h3 id="组件总览"><a href="#组件总览" class="headerlink" title="组件总览"></a>组件总览</h3><p>首先在头部引入<code>Component</code>组件，然后通过<code>class</code>方式继承<code>Component</code>,最后将组件导出，即可成为单独组件使用。需要注意的地方就是组件的首字母一定要<strong>大写</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//引入Component</span><br><span class="line">import &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">//首字母大写！</span><br><span class="line">class MyComponent extends Component&#123;</span><br><span class="line">    </span><br><span class="line">    consturtion(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            isShow:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*react生命周期函数*/</span><br><span class="line">    componentWillMount() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    componentWillReceiveProps() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    shouldComponentUpdate() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    componentWillUpdate() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    componentDidUpdate() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    componentWillUnmount() &#123;&#125;</span><br><span class="line">    //通过render函数可以将JSX语法渲染成真实dom</span><br><span class="line">    render() &#123;      </span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;我是组件&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.props.test&#125;&lt;/p&gt;</span><br><span class="line">                &lt;button onClick=&#123;()=&gt;&#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        isShow:!this.state.isShow,</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;&gt;点我&lt;/button&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.state.isShow&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//首字母大写！</span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">    return &lt;MyComponent test=&quot;我是props&quot; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Parent;</span><br></pre></td></tr></table></figure></p><h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><p>确实说白了就是html标签写到js中去，然后通过babel转译成react虚拟DOM对象，然后再渲染。<br>上例中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;      </span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;我是组件，&#123;this.props.test&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实用的就是JSX语法，那么在标签内可以嵌套js语句。想要嵌套js语句的时候需要用<code>{}</code>包起来。</p><h3 id="渲染虚拟DOM"><a href="#渲染虚拟DOM" class="headerlink" title="渲染虚拟DOM"></a>渲染虚拟DOM</h3><p>关于这一点，要详细说起来还挺长的。考虑到是<strong>快速入门</strong>，于是乎我们就记住一点，当修改值需要react重新渲染的时候，react的机制是<strong>不会让他全部重新渲染</strong>的，它只会把你修改值所在的dom重新更新。这也是为什么react性能快的一大原因。这个选择渲染dom的算法叫做<strong>diff算法</strong>，如果要学习react就不能把这个给忘记。在日后需要好好把这方面的知识补全。这里还要补充的就是，react把JSX语法先转成react对象，然后通过内部创建节点插入到dom当中。还是考虑到<strong>快速</strong>，所以该节篇幅就不继续展开了，这些知识日后需要好好补全。</p><h3 id="组件props"><a href="#组件props" class="headerlink" title="组件props"></a>组件props</h3><p>props如果接触过Vue的话，应该会很好理解这个概念。没接触过也不要紧，因为是比较容易接受的。我们这么理解，其实就是父组件传给子组件的一些东西，可以是基本数据类型，也可以是引用数据类型，也就是说啥都可以传。子组件可以通过<code>this.props</code>这个对象来<strong>获取父组件传下来的值</strong></p><p>还是看回上面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        //这里可以拿到</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;我是组件&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.props.test&#125;&lt;/p&gt;</span><br><span class="line">                &lt;button onClick=&#123;()=&gt;&#123;</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        isShow:!this.state.isShow,</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;&gt;点我&lt;/button&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.state.isShow&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        //通过父组件传进去</span><br><span class="line">        return &lt;MyComponent test=&quot;我是props&quot; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组件state"><a href="#组件state" class="headerlink" title="组件state"></a>组件state</h3><p>组件state是<strong>状态</strong>，这里存放的就是该组件的一些会改变的变量，就是状态。比如判断组件属性变化，获取表单值等。修改state会引起react<strong>重新渲染</strong>，也就是更新状态会引起组件刷新。我们可以通过<code>setState()</code>这个函数来设置state的值。不过要注意的是<code>setState()</code>这个函数是<strong>异步函数</strong>。下面还是看上面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends Component&#123;</span><br><span class="line">    consturtion(props)&#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state=&#123;</span><br><span class="line">            isShow:true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;我是组件&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.props.test&#125;&lt;/p&gt;</span><br><span class="line">                &lt;button onClick=&#123;()=&gt;&#123;</span><br><span class="line">                    //点击后可修改state值</span><br><span class="line">                    this.setState(&#123;</span><br><span class="line">                        isShow:!this.state.isShow,</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;&#125;&gt;点我&lt;/button&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.state.isShow&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h3><p>这个意思实际上就是在一个组件里面可以用别的组件的意思。因此你可以把组件划分得比较细致，以便更多的复用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        //使用了MyComponent组件</span><br><span class="line">        return &lt;MyComponent test=&quot;我是props&quot; /&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p>在这里就说一下组件的生命周期函数吧</p><ul><li><p><code>componentWillMount() {}</code>组件挂载前</p></li><li><p><code>componentDidMount() {}</code>组件挂载完执行</p></li><li><p><code>componentWillReceiveProps() {}</code>组件更新数据时执行，<code>props</code>、<code>state</code></p></li><li><p><code>shouldComponentUpdate() {}</code>组件需要更新时执行</p></li><li><p><code>componentWillUpdate() {}</code>组件更新前执行</p></li><li><p><code>componentDidUpdate() {}</code>组件更新后执行</p></li><li><p><code>componentWillUnmount() {}</code>组件销毁前执行</p></li></ul><p>下面一张图解释生命周期</p><p>当然想要暂时略过也不是不可，但日后需要了解。</p><h2 id="更深入学习react"><a href="#更深入学习react" class="headerlink" title="更深入学习react"></a>更深入学习react</h2><p>学完react，我们还需要知道react-router、redux等react全家桶。还在这推荐一个开源框架DVa.js。当然，这是融合的比较好的，如果学有余力不妨去了解了解</p><p>附上一张学习路线图，供大家学习参考</p><p>图片来源：<strong><a href="https://github.com/adam-golab/react-developer-roadmap" target="_blank" rel="noopener">https://github.com/adam-golab/react-developer-roadmap</a></strong></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>入门react并不难，但是要用得精通却不容易。本文并不指望能让你懂多少react，但是如果能带你入门，那便是他它的成功。希望每个人都能成为自己想要的样子。</p><p>最后，成功不在一朝一夕，我们都需要努力</p><p>原创文章，转载需联系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装react&quot;&gt;&lt;a href=&quot;#安装react&quot; class=&quot;headerlink&quot; title=&quot;安装react&quot;&gt;&lt;/a&gt;安装react&lt;/h2&gt;&lt;p&gt;&lt;code&gt;npm install creat-react-app -g&lt;/code&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Vue实现拖拽效果</title>
    <link href="http://yoursite.com/2018/04/24/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2018/04/24/基于Vue实现拖拽效果/</id>
    <published>2018-04-24T13:00:00.000Z</published>
    <updated>2018-04-24T13:01:28.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://upload-images.jianshu.io/upload_images/10414430-93d8911b63914b85.gif?imageMogr2/auto-orient/strip" alt="demo1.gif"></p><h2 id="分清clientY-pageY-screenY-layerY-offsetY的区别"><a href="#分清clientY-pageY-screenY-layerY-offsetY的区别" class="headerlink" title="分清clientY pageY screenY layerY offsetY的区别"></a>分清clientY pageY screenY layerY offsetY的区别</h2><p>在我们想要做出拖拽这个效果的时候，我们需要分清这几个属性的区别，这几个属性都是计算鼠标点击的偏移值，我们需要对其进行了解才可以继续实现我们的拖拽效果</p><ul><li>clientY 指的是距离可视页面左上角的距离</li><li>pageY 指的是距离可视页面左上角的距离(不受页面滚动影响)</li><li>screenY 指的是距离屏幕左上角的距离</li><li>layerY 指的是找到它或它父级元素中最近具有定位的左上角距离</li><li>offsetY 指的是距离它自己左上角的距离</li></ul><p>一张图带大家简单了解了解</p><p><img src="https://upload-images.jianshu.io/upload_images/10414430-a468320f760ce39f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区别"></p><p>在我们简单了解完这些个属性以后，有几个属性需要分清。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">相同点</th><th style="text-align:center">不同点</th></tr></thead><tbody><tr><td style="text-align:center">clientY</td><td style="text-align:center">距离页面左上角距离</td><td style="text-align:center">受页面滚动的影响</td></tr><tr><td style="text-align:center">pageY</td><td style="text-align:center">距离页面左上角的距离</td><td style="text-align:center">不受页面滚动影响</td></tr></tbody></table><table><thead><tr><th style="text-align:center"></th><th>相同点</th><th>不同点</th></tr></thead><tbody><tr><td style="text-align:center">layerY</td><td>距离元素的左上角距离</td><td>受元素的定位的影响，会从本元素往上找到第一个定位的元素的左上角</td></tr><tr><td style="text-align:center">offsetY</td><td>距离元素左上角的距离</td><td>计算相对于本元素的左上角，不在乎定位问题，计算的是内交点。是IE浏览器的特有属性</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/10414430-6c1bccb989903dfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layerY与offsetY区别"></p><h2 id="实现拖拽功能"><a href="#实现拖拽功能" class="headerlink" title="实现拖拽功能"></a>实现拖拽功能</h2><p>我们既然熟悉了这几个偏移属性的意思，那么我们就进入我们的重点。话不多说直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// darg.html</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #app&#123;</span><br><span class="line">    position: relative;     /*定位*/</span><br><span class="line">    top: 10px;</span><br><span class="line">    left: 10px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: #666;       /*设置一下背景*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot; @mousedown=&quot;move&quot;&gt;       &lt;!--绑定按下事件--&gt;</span><br><span class="line">    &#123;&#123;positionX&#125;&#125;</span><br><span class="line">        &#123;&#123;positionY&#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        positionX:0,</span><br><span class="line">        positionY:0,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        move(e)&#123;</span><br><span class="line">            let odiv = e.target;        //获取目标元素</span><br><span class="line">            </span><br><span class="line">            //算出鼠标相对元素的位置</span><br><span class="line">            let disX = e.clientX - odiv.offsetLeft;</span><br><span class="line">            let disY = e.clientY - odiv.offsetTop;</span><br><span class="line">            document.onmousemove = (e)=&gt;&#123;       //鼠标按下并移动的事件![image](https://note.youdao.com/favicon.ico)</span><br><span class="line">                //用鼠标的位置减去鼠标相对元素的位置，得到元素的位置</span><br><span class="line">                let left = e.clientX - disX;    </span><br><span class="line">                let top = e.clientY - disY;</span><br><span class="line">                </span><br><span class="line">                //绑定元素位置到positionX和positionY上面</span><br><span class="line">                this.positionX = top;</span><br><span class="line">                this.positionY = left;</span><br><span class="line">                </span><br><span class="line">                //移动当前元素</span><br><span class="line">                odiv.style.left = left + &apos;px&apos;;</span><br><span class="line">                odiv.style.top = top + &apos;px&apos;;</span><br><span class="line">            &#125;;</span><br><span class="line">            document.onmouseup = (e) =&gt; &#123;</span><br><span class="line">                document.onmousemove = null;</span><br><span class="line">                document.onmouseup = null;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然，我们可以将它绑定为一个自定义指令，这样的话就可以用调用指令的形式来实现拖拽效果，下面是定义自定义指令的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// darg.html</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    #app&#123;</span><br><span class="line">    position: relative;     /*定位*/</span><br><span class="line">    top: 10px;</span><br><span class="line">    left: 10px;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: #666;       /*设置一下背景*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot; v-drag&gt;       &lt;!--实现用指令形式实现拖拽效果--&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">    el:&apos;#app&apos;,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    methods:&#123;&#125;,</span><br><span class="line">    directives: &#123;</span><br><span class="line">        drag: &#123;</span><br><span class="line">            // 指令的定义</span><br><span class="line">            bind: function (el) &#123;</span><br><span class="line">                let odiv = el;   //获取当前元素</span><br><span class="line">                oDiv.onmousedown = (e) =&gt; &#123;</span><br><span class="line">                    //算出鼠标相对元素的位置</span><br><span class="line">                    let disX = e.clientX - odiv.offsetLeft;</span><br><span class="line">                    let disY = e.clientY - odiv.offsetTop;</span><br><span class="line">                    </span><br><span class="line">                    document.onmousemove = (e)=&gt;&#123;</span><br><span class="line">                        //用鼠标的位置减去鼠标相对元素的位置，得到元素的位置</span><br><span class="line">                        let left = e.clientX - disX;    </span><br><span class="line">                        let top = e.clientY - disY;</span><br><span class="line">                      </span><br><span class="line">                        //绑定元素位置到positionX和positionY上面</span><br><span class="line">                        this.positionX = top;</span><br><span class="line">                        this.positionY = left;</span><br><span class="line">                </span><br><span class="line">                        //移动当前元素</span><br><span class="line">                        odiv.style.left = left + &apos;px&apos;;</span><br><span class="line">                        odiv.style.top = top + &apos;px&apos;;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    document.onmouseup = (e) =&gt; &#123;</span><br><span class="line">                        document.onmousemove = null;</span><br><span class="line">                        document.onmouseup = null;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>到这里我们就已经把拖拽效果用Vue实现了，我们用了两种不同的方式实现了拖拽，但实际上换汤不换药，我们需要弄清楚pageY、screenY、clientY、layerY、offsetY等区别。当然我们同时也学习了Vue的一些方法，例如自定义指令等。</p><p>成功不在一朝一夕间，我们都需要努力</p><p>原创文章，转载需联系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10414430-
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简述JavaScript闭包</title>
    <link href="http://yoursite.com/2018/04/22/%E7%AE%80%E8%BF%B0JavaScript%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/04/22/简述JavaScript闭包/</id>
    <published>2018-04-22T08:22:48.000Z</published>
    <updated>2018-04-22T08:28:36.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引入闭包"><a href="#1-引入闭包" class="headerlink" title="1.引入闭包"></a>1.引入闭包</h2><ul><li>我们先从两个经典例子中提出我们的问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function a(b)&#123;</span><br><span class="line">    var c = &quot;123&quot;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(b);</span><br><span class="line">        console.log(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = a(&quot;b&quot;);</span><br><span class="line">b();    //&quot;b&quot; &quot;123&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let func = function()&#123;</span><br><span class="line">    var arr = new Array();</span><br><span class="line">    for(var i = 0 ; i &lt; 5;i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当然，如果你有了解过相关闭包的知识，那么上面的每个数组函数都会返回<code>5</code>。在这里可以很明确的告诉你这就是闭包。闭包究竟是什么，按照红宝书上面的定义是这么解释的</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数</p></blockquote><p>当然，我觉得闭包有一点也特别重要，创建闭包时就创建了一个<strong>不销毁的作用域</strong>。<br>接下来我就简单的剖析一下闭包，说到闭包总不能忘记几个概念，<strong>作用域链</strong>、<strong>执行上下文</strong>、<strong>变量对象</strong></p><h2 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2.执行上下文"></a>2.执行上下文</h2><p>当我们调用一个函数的时候就会创建一个函数的环境，我们可以称之为<strong>执行环境</strong>，简单点也可称之为环境。当然，咱们在这里叫作<strong>执行上下文</strong>。当然，<strong>每个函数都会有各自的执行上下文</strong>。简单来说，就是函数里面的执行环境。++执行上下文定义了变量或函数有权访问其他数据++，++决定了他们各自的行为++。</p><h2 id="3-变量对象"><a href="#3-变量对象" class="headerlink" title="3.变量对象"></a>3.变量对象</h2><p>每个执行上下文中有会有与之关联的<strong>变量对象</strong>，在上下文中定义的所有变量和函数都会放在这里面。当然我们是取不到它的，我们只能想象它的存在。解析器在处理数据的时候就会在后台使用变量对象。但是如果在函数中的话，我们称之为<strong>活动对象</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">var b = 0;</span><br><span class="line">function abc(c)&#123;</span><br><span class="line">    var b = 1;</span><br><span class="line">    return a+b+c;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abc(3)  //5</span><br></pre></td></tr></table></figure><p>那么上面这个例子是不是闭包？当然不是，第一它没有创建一个不销毁的作用域，第二他没有返回引用类型。但是上面这个函数可以帮我们理解变量对象。那么上例中函数<code>abc</code>的活动对象是<code>b、c</code>，全局的变量对象是<code>a、b</code></p><h2 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4.作用域链"></a>4.作用域链</h2><p><strong>作用域链</strong>是用来指向变量对象的，<strong>作用域的用途是保证对执行环境有权访问的所有变量和函数的有序访问</strong>。作用域的前面，始终都是<strong>当前执行</strong>的代码所在环境的变量对象</p><p>我们回到上面那个<code>abc</code>的例子，在创建abc函数的时候就会创建一个包含全局变量对象的作用域链，当调用<code>abc</code>函数时，就会将<code>abc</code>的活动对象推到作用域链的前端，当函数要寻找变量时就会按照作用域链依次往下找</p><p><img src="http://on-img.com/chart_image/5ac47dede4b00dc8a02ceecc.png" alt="image"></p><p>所以上例子中，<code>abc</code>函数会先在活动对象变量<code>b，c</code>，再到外部去寻找<code>a</code>，因此结果得到为<code>6</code>。</p><h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5.闭包"></a>5.闭包</h2><p>既然作用域链、变量对象、执行上下文我们都简述了一遍，那么接下来我们说回闭包。</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数</p></blockquote><p>我们再一次把闭包的定义扔出来，这下子我们就大概清晰许多了。那么我们接下来创建闭包函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function abc(c)&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let test = abc(2);</span><br><span class="line">let result = test(3);       //6</span><br></pre></td></tr></table></figure></p><p>当我们调用<code>abc</code>函数时，其<code>abc</code>活动对象就会推到作用域链的前端，当我们返回其匿名函数时，匿名函数的活动对象就会被推到作用域链的前端，因此在里面就可以访问到外面的值。</p><p><img src="http://on-img.com/chart_image/5ac58033e4b0cfe27482a194.png" alt="image"></p><p>由于我们将<code>test</code>变量赋予了<code>abc</code>的返回值，函数<code>abc</code>中就产生一个<strong>无法销毁的活动对象</strong>，匿名函数的作用域链一直引用其<code>abc</code>函数活动对象。因此在内存就产生了一个不销毁的活动对象，这也是导致内存泄漏的原因。这么来说，只要<code>test</code>一直存在，那么abc的活动对象都不会被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function abc(c)&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let test = abc(2);</span><br><span class="line">let result = test(3);       //6</span><br><span class="line"></span><br><span class="line">test=null;  //解除对匿名函数引用，释放abc活动对象，随后执行完便可被回收</span><br></pre></td></tr></table></figure></p><p>那么问题又来了，以下的函数算不算闭包呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function abc(c)&#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    return function(b)&#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abc(2)(3);      //6</span><br></pre></td></tr></table></figure></p><p>看上去和上面没什么区别，实际上这已经不是闭包了。原因在于它没有创建一个不销毁的作用域链，它并没有定义一个变量去引用这个匿名函数，所以该函数在执行完以后就会被销毁。这只是一个普通的匿名函数而已。</p><p>说完我们回到第一个问题上面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let func = function()&#123;</span><br><span class="line">    var arr = new Array();</span><br><span class="line">    for(var i = 0 ; i &lt; 5;i++)&#123;</span><br><span class="line">        arr[i] = function()&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个每个数组函数中返回的都是<code>5</code>，原因在于<strong>闭包保存的是整个变量对象</strong>，因此每个函数中都<strong>保存一样的变量对象</strong>。它们引用的都是一个变量<code>i</code>。所以在执行闭包时，<code>i</code>已经执行到<code>5</code>,返回的<code>i</code>自然便是<code>5</code>。</p><ul><li><strong>闭包的作用</strong></li></ul><p>闭包的作用就是可以在内存中保留一些变量，使其不被销毁。当然，还有重要的一点就是可以访问外界的变量与函数，取到另外一个作用域上面的值。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们对闭包的简述就到这里了，想要深入了解闭包还需要花更多功夫在上面。成功不是在一朝一夕之间，我们都需要努力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-引入闭包&quot;&gt;&lt;a href=&quot;#1-引入闭包&quot; class=&quot;headerlink&quot; title=&quot;1.引入闭包&quot;&gt;&lt;/a&gt;1.引入闭包&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们先从两个经典例子中提出我们的问题&lt;figure class=&quot;highlight plain
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/04/22/hello-world/"/>
    <id>http://yoursite.com/2018/04/22/hello-world/</id>
    <published>2018-04-22T01:51:12.139Z</published>
    <updated>2018-04-22T01:51:12.139Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript由浅及深了解原型链（二）</title>
    <link href="http://yoursite.com/2018/03/30/JavaScript%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/30/JavaScript由浅及深了解原型链（二）/</id>
    <published>2018-03-30T09:30:00.000Z</published>
    <updated>2018-07-29T08:24:09.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、对象的继承"><a href="#一、对象的继承" class="headerlink" title="一、对象的继承"></a>一、对象的继承</h2><h3 id="1-了解原型链"><a href="#1-了解原型链" class="headerlink" title="1.了解原型链"></a>1.了解原型链</h3><p>在上一篇我们讲过关于原型对象的概念，当然如果不了解的建议去翻看第一篇文章，文末附有连接。我们知道每个对象都有各自的原型对象，那么当我们把一个对象的实例当做另外一个对象的原型对象。。这样这个对象就拥有了另外一个引用类型的所有方法与属性，当我们再把该对象的实例赋予另一个原型对象时，这样又把这些方法继承下去。如此层层递进，对象与原型间存在链接关系，这样就构成了原型链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.type = &quot;Animal&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function()&#123;</span><br><span class="line">    console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat()&#123;</span><br><span class="line">    this.vioce = &quot;喵喵喵&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">Cat.prototype.shout = function()&#123;</span><br><span class="line">    console.log(this.vioce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line"></span><br><span class="line">//当然，我们还可以继续继承下去</span><br><span class="line"></span><br><span class="line">function Tom()&#123;</span><br><span class="line">    this.name = &quot;Tom&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tom.prototype = new Cat();</span><br><span class="line"></span><br><span class="line">Tom.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat2 = new Tom();</span><br><span class="line">cat2.say();     //&quot;Animal&quot;</span><br><span class="line">cat2.shout();   //&quot;喵喵喵&quot;</span><br><span class="line">cat2.sayName();     //&quot;Tom&quot;</span><br><span class="line">cat1.sayName();     //err 报错表示没有该函数</span><br></pre></td></tr></table></figure></p><p>很神奇的，原型链就实现了对象的继承。使用原型链就可以使一个新对象拥有之前对象的所有方法和属性。至于<code>cat1.sayName()</code>会报错，是因为该方法是在它的子原型对象中定义，所以无法找到该函数。但是我相信很多人看到这里还是会一头雾水，到底链在哪里了？谁和谁链在一起了？我用一张图来让大家更好的理解这个。</p><p><img src="http://on-img.com/chart_image/5abf2655e4b08996548c2663.png" alt="image"></p><p>咋眼一看，这张图信息量不少，但是理解起来却一点都不难。我们先从<code>Animal</code>看起，<code>Animal</code>中存在一个<code>prototype</code>指向其原型对象，这一部分应该没什么问题。但是<code>Animal</code>原型对象中却存在[<code>[prototype]]</code>指向了<code>Object</code>，实际上是指向了<code>Object.prototype</code>。<strong>这是因为所有函数都是从Object继承而来的</strong>，<strong>所有函数都是Object的实例</strong>。这也正是所有的函数都可以拥有Object方法的原因，如<code>toString()</code>。所以这也是原型链的一部分，我们从创建自定义类型开始就已经踏入了原型链中。</p><p>但是这部分我们暂且不管它，我们继续往下面看。我们把<code>Animal</code>的实例当做<code>Cat</code>的原型对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = new Animal();</span><br></pre></td></tr></table></figure></p><p>这样<code>Cat</code>实例就拥有了其父类型的所有方法与属性。因为代码中寻找一个方法会不断往上找，先在实例中寻找，如果没有就在原型对象中去寻找，假如原型对象中没有，就会往原型对象的原型对象中去找，如此递进，最终如果找到则返回，找不到则报错。当我们构成原型链时，会有一个对象原型当做其父类型的实例，这样便形成一条原型链。当然，如果现在有不明白 <code>[[prototype]]</code> (<code>__proto__</code>)与<code>prototype</code>的区别可以去翻看我们第一篇文章，在这就不重复了。</p><p>这样一来我们便明白了为何<code>cat1</code>中没有<code>sayName</code>函数并了解原型链如何实现继承了。但是我又提出了一个问题，假如我们把给子类型原型对象定义方法的位置调换一下，那么会发生什么事呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.type = &quot;Animal&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function()&#123;</span><br><span class="line">    console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat()&#123;</span><br><span class="line">    this.vioce = &quot;喵喵喵&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.shout = function()&#123;</span><br><span class="line">    console.log(this.vioce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line">cat1.shuot();       //err，报错无此函数</span><br></pre></td></tr></table></figure><p>控制台中会毫不留情的告诉你，没有该方法<code>Uncaught TypeError: cat1.shuot is not a function</code>。这是因为当你把父类的实例赋给子类原型对象时，会将其替换。那么你之前所定义的方法就会失效。所以在这里要注意的一点就是：<strong>给原型添加方法时一定要在替换原型语句之后</strong>，而且还有一点要注意就是，在用原型链实现继承的时候，<strong>千万不可以用字面量形式定义原型方法</strong>。不然原型链会断开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.type = &quot;Animal&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function()&#123;</span><br><span class="line">    console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat()&#123;</span><br><span class="line">    this.vioce = &quot;喵喵喵&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">Cat.prototype = &#123;       //这样会使上一条语句失效，从而使原型链断开。</span><br><span class="line">    shout:function()&#123;</span><br><span class="line">        console.log(this.vioce);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-原型链的问题"><a href="#2-原型链的问题" class="headerlink" title="2.原型链的问题"></a>2.原型链的问题</h3><p>接下来我们谈谈原型链的问题。说起原型链的问题我们大概可以联想到原型对象的问题：<strong>其属性与方法会被所有实例共享</strong>，那么在原型链中亦是如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.type = &quot;Animal&quot;;</span><br><span class="line">    this.color = [&quot;white&quot;,&quot;black&quot;,&quot;yellow&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function()&#123;</span><br><span class="line">    console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat()&#123;</span><br><span class="line">    this.vioce = &quot;喵喵喵&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">Cat.prototype.shout = function()&#123;</span><br><span class="line">    console.log(this.vioce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();</span><br><span class="line">let cat2 = new Cat();</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line">cat1.color.push(&quot;pink&quot;);</span><br><span class="line"></span><br><span class="line">console.log(cat1.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;pink&quot;]</span><br><span class="line">console.log(cat2.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;pink&quot;]</span><br></pre></td></tr></table></figure></p><p>当然，这也好理解不是。倘若孙子教会了爷爷某件事，那么爷爷会把他的本领传个他的每个儿子孙子，没毛病对吧。但是我们想要的是，孙子自己学会某件事，但不想让其他人学会。这样意思就是每个实例拥有各自的属性，不与其他实例共享。那么我们就引入了借用构造函数的概念了。</p><h3 id="3-借用构造函数"><a href="#3-借用构造函数" class="headerlink" title="3.借用构造函数"></a>3.借用构造函数</h3><p>借用构造函数，简单来说就是在子类构造函数里面调用父类的构造函数。要怎么调用？可以使用到<code>apply()</code>和<code>call()</code>这些方法来实现这个功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Animal(type = &quot;Animal&quot;)&#123;       //设置一个参数，如果子类不传入参数则默认为&quot;Animal&quot;</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.color = [&quot;white&quot;,&quot;black&quot;,&quot;yellow&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat(type)&#123;</span><br><span class="line">    Animal.call(this,type);     //继承Animal同时传入type，也可以不传参</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();           //没有传参，type默认为&quot;Animal&quot;</span><br><span class="line">let cat2 = new Cat(&quot;Cat&quot;);      //传入&quot;Cat&quot;,type则为&quot;Cat&quot;</span><br><span class="line"></span><br><span class="line">cat1.color.push(&quot;pink&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(cat1.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;pink&quot;]</span><br><span class="line">console.log(cat2.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;]</span><br><span class="line">console.log(cat1.type);     //&quot;Animal&quot;</span><br><span class="line">console.log(cat2.type);     //&quot;Cat&quot;</span><br></pre></td></tr></table></figure></p><p>这样就实现了实例属性不共享的功能，而且我们在这个里面还可以传入一个参数，让其向父类传参。这是在原型链里面无法做到的一个功能。至于<code>call()</code>与<code>apply()</code>方法，在这暂且不展开，日后另作文章阐明。暂且只需要知道这是改变函数作用域的就行。</p><p>那么，借用构造函数的问题也就是构造函数的问题，方法都定义在构造函数里面了，复用性就基本凉凉。所以，我们要组合起来使用。<strong>属性使用借用构造函数模式</strong>，<strong>而方法则使用原型链</strong>。</p><h3 id="4-组合继承"><a href="#4-组合继承" class="headerlink" title="4.组合继承"></a>4.组合继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.type = &quot;Animal&quot;;</span><br><span class="line">    this.color = [&quot;white&quot;,&quot;black&quot;,&quot;yellow&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function()&#123;</span><br><span class="line">    console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat()&#123;</span><br><span class="line">    Animal.call(this);      //继承属性</span><br><span class="line">    </span><br><span class="line">    this.vioce = &quot;喵喵喵&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = new Animal();       //继承方法</span><br><span class="line"></span><br><span class="line">Cat.prototype.shout = function()&#123;</span><br><span class="line">    console.log(this.vioce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();</span><br><span class="line">let cat2 = new Cat();</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line">cat1.color.push(&quot;pink&quot;);</span><br><span class="line"></span><br><span class="line">console.log(cat1.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;pink&quot;]</span><br><span class="line">console.log(cat2.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;]</span><br></pre></td></tr></table></figure><p>这一套方法也变成了<strong>最常用的继承方法</strong>了。但是其中也是有个缺陷，就是每次都会调用两次父类的构造函数。从而使得实例中与原型对象中创造相同的属性，不过原型对象中的值却毫无意义。那有没有更完美的方法？有，就是<strong>寄生组合式继承</strong>。在这里我就放代码给大家。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function obj(o)&#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function inheritPrototype(sub,super)&#123;</span><br><span class="line">    let prototype = obj(super.prototype);       //相当于拷贝了一个父类对象</span><br><span class="line">    prototype.constructor = sub;    增强对象</span><br><span class="line">    sub.prototype = prototype;      指定对象</span><br><span class="line">&#125;</span><br><span class="line">function Animal()&#123;</span><br><span class="line">    this.type = &quot;Animal&quot;;</span><br><span class="line">    this.color = [&quot;white&quot;,&quot;black&quot;,&quot;yellow&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.say = function()&#123;</span><br><span class="line">    console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Cat()&#123;</span><br><span class="line">    Animal.call(this);      //继承属性</span><br><span class="line">    </span><br><span class="line">    this.vioce = &quot;喵喵喵&quot;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Cat,Animal);</span><br><span class="line"></span><br><span class="line">Cat.prototype.shout = function()&#123;</span><br><span class="line">    console.log(this.vioce);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();</span><br><span class="line">let cat2 = new Cat();</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line">cat1.say();     //&quot;Animal&quot;</span><br><span class="line">cat1.color.push(&quot;pink&quot;);</span><br><span class="line"></span><br><span class="line">console.log(cat1.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;, &quot;pink&quot;]</span><br><span class="line">console.log(cat2.color);    //[&quot;white&quot;, &quot;black&quot;, &quot;yellow&quot;]</span><br></pre></td></tr></table></figure></p><p>这样通过一个巧妙的方法就可以少调用一次父类的构造函数，而且不会赋予原型对象中无意义的属性。这是被认为最理想的继承方法。但是最多人用的还是上面那个组合式继承方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这原型链的基本概念与用法都已经一一讲述，我们需要注意的地方就是<code>prototype</code>与<code>__proto__</code>的关系，重点是分清其中的区别，了解父类型跟其子类型的关系，他们之间的联系在哪。大概要弄懂的地方，就是要把那两文章的两张图吃透，那么我们就已经把原型链吃透大半了。</p><p>最后倘若大家还有什么不懂的地方，或者博主有什么遗漏的地方，欢迎大家指出交流。接下来我还会写一篇关于<code>call()</code>与<code>apply()</code>这两个方法的文章。如有兴趣可以持续关注本博主。</p><p>附上该文章第一篇：<a href="https://www.jianshu.com/p/80459aab87ca" target="_blank" rel="noopener">《JavaScript由浅及深了解原型链（一）》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、对象的继承&quot;&gt;&lt;a href=&quot;#一、对象的继承&quot; class=&quot;headerlink&quot; title=&quot;一、对象的继承&quot;&gt;&lt;/a&gt;一、对象的继承&lt;/h2&gt;&lt;h3 id=&quot;1-了解原型链&quot;&gt;&lt;a href=&quot;#1-了解原型链&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript由浅及深敲开原型链（一）</title>
    <link href="http://yoursite.com/2018/03/29/JavaScript%E7%94%B1%E6%B5%85%E5%8F%8A%E6%B7%B1%E4%BA%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/03/29/JavaScript由浅及深了解原型链（一）/</id>
    <published>2018-03-29T08:00:00.000Z</published>
    <updated>2018-07-29T08:24:24.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-什么是js对象"><a href="#一-什么是js对象" class="headerlink" title="一.什么是js对象"></a>一.什么是js对象</h2><h3 id="1-简单理解js对象"><a href="#1-简单理解js对象" class="headerlink" title="1.简单理解js对象"></a>1.简单理解js对象</h3><p>在了解<strong>原型链</strong>之前，我们先要弄清楚什么是<strong>JavaScript的对象</strong>，JavaScript对象又由哪些组成。有人说一个程序就是一个世界，那么我们可以把对象称之为这个世界的组成类型，可以是生物，植物，生活用品等等。我们在<strong>java</strong>中管这些类型叫做<strong>类</strong>，但是在JavaScript中没有类的说法，当然<strong>ES6</strong>新标准中开始出现了类。但是在此之前，我们都管这些类型叫做<strong>对象</strong>。那么对象创建出来的实例就是就是组成该世界的各个元素，如一个人、一只小狗、一棵树等等。这些就称之为<strong>对象的实例</strong>。那么每种类型都有它不同的属性和方法，同样的JavaScript对象也是由对象属性和对象方法组成。当然了每个实例还可以存在与对象不一样的方法与属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&quot;xiaoming&quot;,    //对象属性</span><br><span class="line">    sayName:function()&#123;    //对象方法</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-js对象属性的特性"><a href="#2-js对象属性的特性" class="headerlink" title="2.js对象属性的特性"></a>2.js对象属性的特性</h3><p>在JavaScript对象中，每个属性都有其各自的特性，比如你的性别具有不可修改的特性。那么下面简单粗略介绍一下这几个特性。这些特性在JavaScript中是不能直接访问的，特性是内部值。</p><ul><li>[[Configurable]]: 表示能不能删除重新定义属性，能不能修改属性等 默认true</li><li>[[Enumerable]]: 表示能不能通过for-in遍历等 默认true</li><li>[[Writeable]]: 表示能不能修改属性值 默认true</li><li>[[Value]]: 表示属性的值，写入到这里，读从这里读 默认undefined</li></ul><p>如果要修改属性的默认特性，可以使用<code>Object.defineProperty()</code>方法，当然在这里就不再继续展开了。接下来我们开始介绍对象的创建</p><h2 id="二-创建JavaScript对象"><a href="#二-创建JavaScript对象" class="headerlink" title="二.创建JavaScript对象"></a>二.创建JavaScript对象</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,sex)&#123;</span><br><span class="line">    let obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.sex = sex;</span><br><span class="line">    obj.sayName = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = new createPerson(&quot;小明&quot;,&quot;男&quot;);</span><br></pre></td></tr></table></figure><p>这就是<strong>工厂模式</strong>，在函数内创建对象，然后在函数内封装好后返回该对象。但是该方法有个缺点就是看不出该对象的类型，于是乎构造函数模式应运而生。</p><h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2.构造函数模式"></a>2.构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.color = color;</span><br><span class="line">    this.sayName = &#123;</span><br><span class="line">        console.log(&quot;我是&quot;+name+&quot;猫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let Tom = new Cat(&quot;Tom&quot;,&quot;灰白&quot;);</span><br><span class="line">let HelloKity = new Cat(&quot;HelloKity&quot;,&quot;粉红&quot;);</span><br></pre></td></tr></table></figure><p><strong>构造函数模式</strong>和<strong>工厂模式</strong>的区别在于，构造函数模式没有<code>用return</code>语句，直接把属性赋给了<code>this</code>语句，并且没有显式的创建对象。当然，如果细心的朋友应该会发现函数名首字母大写了，这是约定在构造函数时将首字母大写。</p><p>用构造函数创建新实例时，必须要用<code>new</code>操作符。同时，每个由构造函数创建的实例都会有一个<code>constructor</code>指向该构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tom.constructor == Cat  //true</span><br></pre></td></tr></table></figure></p><p>这时候我们就会想一个问题，我们在创建不同的<code>Cat</code>实例时，我们就会创建多个不同<code>sayName</code>函数，但是他们执行的功能都是一样的，这时候我们就会想要一种更优化的方法。这时，我们需要引入<strong>原型属性</strong>(<strong>prototype</strong>)的概念了</p><h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3.原型模式"></a>3.原型模式</h3><p>我们创建的每个函数里面都会有个<code>prototype</code>属性，这个就是原型属性，这个属性是个指针，指向一个该函数的原型对象。我们可以捋一捋对象，对象原型，实例这三者的关系，简单来说，我们可以把对象想象成爸爸，那么对象原型就是爷爷，实例的话好比是儿子。爷爷有的东西（属性、方法），每个儿子都会遗传到的，当然如果爸爸把爷爷的东西修改了一下，那么到儿子手上的就是爸爸修改过的东西了（方法重写）。当然，儿子也算是爷爷骨肉嘛，那么儿子就会有个指针<code>[[prototype]]</code>指向爷爷，在Chrome、Firefox等浏览器上面可以用属性<code>__proto__</code>可以访问到。</p><ul><li><h4 id="那么prototype和-proto-区别在哪？"><a href="#那么prototype和-proto-区别在哪？" class="headerlink" title="那么prototype和__proto__区别在哪？"></a>那么<code>prototype</code>和<code>__proto__</code>区别在哪？</h4></li></ul><p>这么说，简单的说<code>prototype</code>是指向各自的爸爸，<code>__proto__</code>是指向各自的爷爷。当然这说法只是为了更好理解这两者是有区别的。接下来我给大家做一个图让大家更好的理解这两者的区别。</p><p><img src="http://on-img.com/chart_image/59426090e4b04d4c799d1ccf.png" alt="image">;</p><p>这大概也是明白为什么对象实例存在个<code>constructor</code>指针指向对象了，因为对象原型上面存在这个属性指向该对象，而且原型最初只包含该<code>constructor</code>属性。<strong>而实例寻找属性值的时候会向上找，先在实例中搜索该属性，没有的话向对象原型寻找。所以最后找到并返回该值</strong>。这样就能很清楚的分开<code>prototype</code>和<code>__proto__</code>的区别了。<code>prototype</code>是对象的属性，而<code>__proto__</code>是对象实例的属性。</p><p>那么我们基本了解<code>prototype</code>属性以后，我们就可以给大家说说原型模式了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function Cat()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.name = &quot;Tom&quot;;</span><br><span class="line">Cat.prototype.color = &quot;灰白&quot;;</span><br><span class="line">Cat.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();</span><br><span class="line">let cat2 = new Cat();</span><br><span class="line"></span><br><span class="line">cat1.sayName();     //&quot;Tom&quot; </span><br><span class="line">cat2.sayName();     //&quot;Tom&quot;</span><br><span class="line"></span><br><span class="line">console.log(cat1.color);      //&quot;灰白&quot;</span><br><span class="line">console.log(cat2.color);      //&quot;灰白&quot;</span><br><span class="line"></span><br><span class="line">//因为对象原型是共享属性与方法，所以所有实例都可以访问到</span><br><span class="line"></span><br><span class="line">//接下来玩点更复杂的</span><br><span class="line"></span><br><span class="line">Cat.sayName = function()&#123;</span><br><span class="line">    console.log(&quot;我是Cat&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cat1.sayName = function()&#123;</span><br><span class="line">    console.log(&quot;我是cat1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat3 = new Cat();</span><br><span class="line"></span><br><span class="line">cat1.sayName();     //&quot;我是cat1&quot;</span><br><span class="line">cat2.sayName();     //&quot;Tom&quot;</span><br><span class="line">cat3.sayName();     //&quot;Tom&quot;</span><br><span class="line">Cat.sayName();      //&quot;我是Cat&quot;</span><br></pre></td></tr></table></figure></p><p>这时候很多人就懵了，为什么<code>cat3</code>说的是<code>&quot;Tom&quot;</code>，而不是输出<code>&quot;我是Cat&quot;</code>。这是因为 Cat.sayName 这个函数是类方法，我们要注意一点，<code>Cat</code>也是一个函数，函数就是一个对象，可以为其添加方法和属性。所以我们在实例中调用sayName并不是调用该类方法。我们还需要分清类方法与对象方法的区别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;      //通过对象实例调用</span><br><span class="line">    this.say = function()&#123;</span><br><span class="line">        console.log(&quot;我是Person对象方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.say = function()&#123;        //只能通过Person调用</span><br><span class="line">    console.log(&quot;我是Person类方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say = function()&#123;      //通过对象实例调用</span><br><span class="line">    console.log(&quot;我是Person对象原型方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，也许还是会有点懵，为什么后面的<code>cat1.sayName();     //&quot;我是cat1&quot;</code>，<strong>因为对象实例方法会屏蔽掉原型的方法</strong>。我们之前说过，当代码读取对象的某个属性时，它会先从该对象实例开始搜索，如果找不到再往上搜索。所以当你定义了对象实例的方法时，如果跟对象原型中的同名，那么该对象实例的方法就会屏蔽掉对象原型中的方法。所以<code>cat1</code>第二次输出的是<code>我是cat1</code>。</p><h4 id="到这里，我再总结一下对象原型，对象与对象实例之间的关系。"><a href="#到这里，我再总结一下对象原型，对象与对象实例之间的关系。" class="headerlink" title="到这里，我再总结一下对象原型，对象与对象实例之间的关系。"></a>到这里，我再总结一下对象原型，对象与对象实例之间的关系。</h4><ul><li><p><strong>对象原型内的方法与属性可以供所有的对象实例访问</strong>，<strong>实现共享性</strong>。</p></li><li><p><strong>对象的</strong><code>prototype</code><strong>属性可以找到对象原型</strong>，<strong>而对象实例的</strong><code>[[proto]]</code><strong>可以找到对象原型</strong></p></li><li><p><strong>对象实例可以重写对象原型方法</strong>，<strong>使其屏蔽对象原型的方法</strong></p></li><li><strong>对象原型一开始只有</strong><code>constructor</code><strong>属性</strong>，<strong>该属性指向该对象</strong></li><li><strong>分清对象原型方法</strong>，<strong>对象方法</strong>，<strong>对象实例方法</strong>，<strong>类方法区别</strong>。<strong>类方法不需要通过实例化对象去访问</strong>，<strong>而其他的都要对象实例去访问</strong></li></ul><p>那么到这里我们已经弄懂了对象原型，对象与对象实例之间的关系。下面我再介绍一种简单的原型语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Cat()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = &#123;</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    color:&quot;灰白&quot;,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我就以字面量的形式创建了新对象，但是有个不一样的地方就是<code>constructor</code>属性不指向<code>Cat</code>，因为我们创建一个函数就会创建它的原型对象，原型对象里面自动获得<code>constructor</code>属性，那么我们再这样的情况下，重写了整个原型对象。所以此时的<code>constructor</code>属性指向了<code>Object</code>。那么我们如果非要这个属性怎么办？很好办，我们自己给它加上就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Cat()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = &#123;</span><br><span class="line">    constructor:&quot;Cat&quot;,</span><br><span class="line">    name:&quot;Tom&quot;,</span><br><span class="line">    color:&quot;灰白&quot;,</span><br><span class="line">    sayName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后我们讲一下原型模式的缺点，原型模式的缺点也很明显，就是它的共享性。成也共享败也共享。这让我突然想起共享单车。废话不多说，直接撸码上来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Cat()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.name = &quot;Tom&quot;;</span><br><span class="line">Cat.prototype.color = &quot;灰白&quot;;</span><br><span class="line">Cat.prototype.catchMouse = [&quot;Jerry&quot;];</span><br><span class="line">Cat.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat();</span><br><span class="line">let cat2 = new Cat();</span><br><span class="line"></span><br><span class="line">cat1.catchMouse.push(&quot;Mickey&quot;);</span><br><span class="line"></span><br><span class="line">console.log(cat1.catchMouse);       //[&quot;Jerry&quot;, &quot;Mickey&quot;]</span><br><span class="line">console.log(cat2.catchMouse);       //[&quot;Jerry&quot;, &quot;Mickey&quot;]</span><br></pre></td></tr></table></figure></p><p>因为原型上面的属性是所有实例都可以访问的，那么当添加往<code>catchMouse</code>属性添加一个值时，所有实例皆可以访问到该属性。这就让人们很头疼了，每个实例的属性应该都是不一样的才对，起码正常来说，但是这样弄得大家都一样的话，就有问题了。这时候，聪明的人应该都可以想到，将构造函数模式和原型模式组合起来就可以了。</p><h3 id="4-组合构造函数模式和原型模式"><a href="#4-组合构造函数模式和原型模式" class="headerlink" title="4.组合构造函数模式和原型模式"></a>4.组合构造函数模式和原型模式</h3><p>将其组合起来，结合他们两的优点，是普遍认同度最高的对象创建模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.color = color;</span><br><span class="line">    this.catchMouse = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat1 = new Cat(&quot;Tom&quot;,&quot;灰白&quot;);</span><br><span class="line">let cat2 = new Cat(&quot;HellowKity&quot;,&quot;粉红&quot;);</span><br><span class="line"></span><br><span class="line">cat1.catchMouse.push(&quot;Jerry&quot;);</span><br><span class="line"></span><br><span class="line">cat1.sayName();     //&quot;Tom&quot;</span><br><span class="line">cat2.sayName();     //&quot;HellowKity&quot;</span><br><span class="line">console.log(cat1.catchMouse);       //[&quot;Jerry&quot;]</span><br><span class="line">console.log(cat2.catchMouse);       //[]</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本篇介绍了对象与对象的创建方法。同时引入并介绍了对象原型的概念。解析了对象原型，对象与对象实例间的关系。我们在下一篇将会解析原型链的概念以及对象的继承与原型链的关系，带大家敲开原型链的奥秘。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-什么是js对象&quot;&gt;&lt;a href=&quot;#一-什么是js对象&quot; class=&quot;headerlink&quot; title=&quot;一.什么是js对象&quot;&gt;&lt;/a&gt;一.什么是js对象&lt;/h2&gt;&lt;h3 id=&quot;1-简单理解js对象&quot;&gt;&lt;a href=&quot;#1-简单理解js对象&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
